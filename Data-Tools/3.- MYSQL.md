# sql:

Este lenguaje no hace diferenciación, como python, entre mayúsculas y minúsculas por lo tanto esto no es un problema.

Es necesario tener el "sql" en el path de comandos para ello pegamos la ruta "C:\Program Files\sql\sql Server 8.0\bin" al path.

* **` ; `** : Indica que termina el código ahí para ejecutarse aparte. Separa el orden de ejecución.

* **` * `** : Indica **"Todo"**

* **` -- `** : Indica Comentario, omite toda la linea de código.

* **` `` `** : Indica Texto, se puede nombrar columnas con espacios usando **\`columna a\`**

* **` @ `** : Indica **VARIABLE** se usan para almacenar datos en ellas.

## 1.- *Comandos para Tablas:*

### Comandos:

* **` SOURCE `** : Se usa para **importar** una base de datos con sus tablas de un archivo ``.sql`` .<br>
`SOURCE` (Dirección del archivo.sql)
    ```sql
        SOURCE C:\Users\Foster-PC\Documents\Visual Studio Code\Learning\MySQL\Ejemplo.sql
    ```
* **` CREATE `** : Se usa para crear una nueva base de datos o tablas dentro de una BD. Añadiendo un espacio indicamos el nombre de nuestra nueva base de datos. En el caso de la creación de una tabla es conveniente indicar el nombre de sus columnas y tipo de datos a contener.
    * Crear una Base de datos
        ```sql
            CREATE DATABASE nombre_A;
        ```
    * Crear una Tabla: (nombre) (tipo) (atributo). En la ultima linea indicamos que columna tendrá el atributo `PRIMARY KEY`, pero también se lo podemos indicar al inicio.
        ```sql
        CREATE TABLE Tabla_A(
            CI INT(10) NOT NULL,
            NOMBRE VARCHAR(20),
            APELLIDO VARCHAR(20),
            DIRECCIÓN TEXT(50),
            TELÉFONO INT(8),
            PRIMARY KEY (CI)
            );
        
        ```
        Otro Ejemplo:
        ```sql
        CREATE TABLE Tabla_B(
            COD_PRODUCTO INT(15) PRIMARY KEY AUTO_INCREMENT NOT NULL,
            NOMBRE VARCHAR(20)
                            )AUTO_INCREMENT = 100;
        
        ```
        Crear Tabla sacado de una vista:
        ```sql
        Create Table morosos AS (
            SELECT * FROM clientes_morosos);
            
        ```
    * Para la creación de una tabla dependiente de llaves externas o en combinación con externas e interna: Indicamos el `PRIMARY KEY` con las columnas que son PK de otras tablas que estamos jalando sus columnas o combinación de externa con interna.
        ```sql
        CREATE TABLE Tabla_C(
            CI INT(13),
            COD_PRODUCTO INT(13),
            FECHA_COMPRA DATE,
            CANTIDAD INT (100),
            PRIMARY KEY (CI,COD_PRODUCTO)
             );
             
        ```
    * Para crear una copia de otra tabla:
        ```sql
        CREATE TABLE archivo_ventas AS
        SELECT * FROM ventas
        
        ```
    * `CREATE OR REPLACE VIEW` : Para la Creación de una Vista. Podemos usar estas vistas como tablas y llamar (DB.Nombre_View) y hacer JOINS, filtros , etc.<br>
    La forma mas usada es combinándola con `OR REPLACE` para que nuestra vista este abierta a modificaciones o se cree en caso se haya eliminado. Para añadir algún filtro la vista no debe contener funciones de agregación o `NO DISTINCT`.<br> **Los Datos o información que borremos de las vistas están ligadas a las tablas y borran datos de sus respectivas fuentes de donde se armaron las vistas**.<br><br>
        CREATE VIEW Nombre AS (CÓDIGO)
        ```sql
            CREATE OR REPLACE VIEW ventas_empleados AS 
            SELECT 
                l.Letra_zona,
                l.Telefono,
                v.venta,
                v.venta_empleado,
                e.Nombre

            FROM local l
            LEFT JOIN ventas v
                ON l.ID_Local = v.ID_Local
            LEFT JOIN empleados e
                ON v.venta_empleado = e.ID_empleado;

            -- Elimina una vista
            DROP VIEW venta_empleado.
        ```
    * `CREATE PROCEDURE`: Es un procedimiento. Se usa para crear una acción (Función), esta puede contener una vista dentro. Es obligatoria indicar el uso de `BEGIN` y `END`.<br> Para VSCODE no es necesario cambiar los `DELIMITER`. Podemos especificar el procedimiento usando parámetros "( )", por nomenclatura es recomendable nombrar las columnas con un p_nombre_columna; y para las `CREATE PROCEDURE` con un sp_nombre_procedimiento.<br>
    Es importante cerrar nuestro código antes del `END` con una **" ; "**.
        ```sql
            CREATE PROCEDURE sp_ventas_pizza (
                    p_venta_empleado INT (7) 
                                            )
            BEGIN
                SELECT *
                FROM ventas v
                WHERE v.clave_producto = "pzz" AND venta_empleado = p_venta_empleado;
            END;

            -- Llamamos el procedimiento que hemos guardado previamente.
            -- Usamos el argumento que hemos indicado con el código de venta_empleado (7 dígitos) 
            CALL sp_ventas_pizza (2310967);

        ```
    * `CREATE TRIGGER` : Sirve para que al modificar una celda afecte a otra celda automáticamente. Para lo cual puede ejecutarse el código antes o después de un `INSERT`, `UPDATE` o `DELETE` (Son DML comandos de manipulación).
 
    * `CREATE EVENT`: Es un bloque de código que se va a ejecutar cada cierto tiempo, periodo o intervalos (como una alarma).
        ```sql
            SET GLOBAL event_scheduler = ON;
            
            CREATE EVENT anual_borrar_fila_auditoria
            ON SCHEDULE 
                EVERY 1 YEAR STARTS "2020-12-25" ENDS "2023-12-25"

            DO BEGIN
                DELETE FROM auditoria_pagos
                WHERE Fecha < NOW() - INTERVAL 1 YEAR;
            END;

        ```

* **`ALTER`** : Modifica cualquier código creado con `CREATE`, solo lo reemplazamos por `ALTER` y podremos modificar cualquier parte del código previamente creado y guardarlo. También podemos habilitar y deshabilitar un código previamente creado.
    ```sql
        ALTER EVENT ...
        ALTER TRIGGER ...
        ALTER PROCEDURE ...
        ALTER TABLE ...

        ALTER Nombre_EVENTO_TRIGGER_PROCEDURE DISABLE

    ```
    * **`ALTER TABLE`** : Modifica la tabla sea tipo de columnas o añadir o quitar columnas.
  
       * Añadir `ADD` o quitar `DROP` una columna. Por defecto se añadirá al final de las columnas. Pero podemos indicar donde queremos ubicar nuestra nueva columna con los comandos `AFTER`(Columna) o `FIRST`.
        ```sql
            ALTER TABLE Cliente ADD Teléfono INT(10) AFTER Nombre;
            
            <!--Ubicar al inicio como primera columna (no es usual)  -->
            ALTER TABLE Cliente ADD Teléfono INT(10) FIRST;
        ```
       * Cambiar el nombre de una columna. `CHANGE` (nombre actual) (Nuevo Nombre)
  
        ```sql
            ALTER TABLE Cliente CHANGE Teléfono Celular INT(10);
        ```
       * Cambiar el Tipo de dato de una columna. `MODIFY` (nombre columna) (Tipo de dato) (Primary Key o mas modificaciones)
  
        ```sql
            ALTER TABLE Cliente MODIFY Celular INT(12) NOT NULL;
        ```
       * Eliminar una llave foránea.
  
        ```sql
            ALTER TABLE Cliente DROP FOREIGN KEY fk_clientes_compras;
        ```


* **` DESCRIBE `** : Muestra como fue hecha la tabla los parámetros y atributos que contiene cada columna.
    ```sql
        DESCRIBE Tabla_A
    ```
* **` SHOW `** : Muestra las bases de datos que tenemos y también las tablas que tenemos dentro de un DB. Las muestra en orden alfabético.
    ```sql
        SHOW DATABASES Nombre;
        SHOW TABLES Nombre;
        SHOW TRIGGERS LIKE "pago%";

        SHOW CREATE TABLE Nombre; <!-- Muestra las llaves foráneas -->
    ```

*  **` DROP `** : Elimina cualquier cosa que le indiquemos. En este ejemplo eliminar una base de datos. Se suele usar en caso de cometer algún error en la creación de DB o Tablas es necesario borrarlas y volverlas a crear.
    ```sql
        DROP DATABASE nombre_A;
        DROP VIEW VISTA_A;
        DROP PROCEDURE sp_nombre;
        DROP PROCEDURE IF EXISTS sp_nombre;

        
    ```
*  **` TRUNCATE `** : Elimina todos los datos de la tabla (``TABLE``) excepto los nombres de las columnas.
    ```sql
        TRUNCATE TABLE datos.archivo_venta;

        INSERT INTO archivo_venta
        SELECT * FROM ventas
        WHERE venta > 1000;
        -- rellenamos datos a la tabla con un filtro de otra tabla (copia)
        
    ```
    * También es usado para eliminar decimales.

        ```sql
            SELECT TRUNCATE(2.343, 1)
        ```
*  **` DELETE FROM `** : Elimina datos específicos entre columnas y filas a señalar.
    ```sql
        DELETE FROM ingredientes
        WHERE ingredientes_id IN (8,9,10) 
        -- Manera más especifica.
        
        WHERE ingredientes_id BETWEEN 8 AND 10;
        -- Borramos filas del 8 al 10 <-- En un rango.
        
    ```
    Eliminar todos los datos de un tabla sin eliminar la tabla:
    ```sql
        DELETE FROM clientes;
    
    ```

* **` USE `** : Selecciona, sitúa en una **Base de datos**.
* **` SELECT `** : Selecciona las **columnas** de una tabla que se mostraran al ejecutar. Pueden ser todas " * " o indicamos una o varias en específico. Para referencias una columna nueva que puede contener una operación previa usamos los paréntesis "(`SELECT` Col_New)"
    ```sql
        SELECT * FROM datos.empleados;

        SELECT id_zona, venta, id_cliente from ventas

    ```
    * También se puede Usar `SELECT` con las **Funciones de Agregación**.
        ```sql
            SELECT AVG(Edad) AS Promedio_Edad
            FROM empleados

        ```
    * Creando Columnas que contengan operaciones previas y referenciandolas para otras columnas con más operaciones.

        ```sql
            SELECT v.ventas_id, v.venta, 
            (SELECT AVG(venta) FROM ventas) AS promedio_venta,
            venta - (SELECT promedio_venta) AS `Diferencia_P.Venta` 
            FROM ventas v

        ```
    * Podemos crear visualizaciones indicando nuevas columnas con datos desde `SELECT` para una visualización mas personalizada. Estos datos añadido solo afectan la visualización y no añade nada a la tabla.

        ```sql
            SELECT "2017" AS Año, SUM(venta) AS Total_Año
            FROM ventas
            WHERE YEAR(fecha_venta) = YEAR(NOW()) - 3

        ```
    * `SELECT...INTO`: Sirve para asignar operaciones del `SELECT` y guardarlas en un variable que ya hemos definido (`DECLARE`).

        ```sql
            CREATE PROCEDURE sp_venta_mejora_YOY ()
            BEGIN
                DECLARE factor_mejora DECIMAL (9,1) DEFAULT 0;
                DECLARE ventas_conteo INT;
                DECLARE ventas_total DECIMAL (9,1) DEFAULT 0;

                SELECT COUNT(*), SUM(venta)
                INTO ventas_conteo, ventas_total
                FROM ventas;

                SET factor_mejora = ventas_total/ventas_conteo * 1.10;

                SELECT factor_mejora;

            END;
        ```
* **` FROM `** : Indica de que **tabla** se sacaran los datos. Podemos también asignar un nombre o letra con la que identifiquemos la tabla que estamos indicando.
    ```sql
        select * from ventas v
        join local l on v.ID_local = l.ID_local
        
    ```
    * Sub Queries: De una vista (Query) anterior la podemos usar como una tabla de entrada en `FROM`. Para ellos es necesario terminar de citar la tabla asignándole un nombre (AS tb_A). Y es este nombre asignado el que tomaremos de referencia para mostras nuestras columnas (`SELECT` tb_A.nombre ,SUM(tb_A.pago), SUM(tb_A.saldo):
        ```sql
            SELECT *
            FROM (
                SELECT v.ventas_id, v.venta, 
                (SELECT AVG(venta) FROM ventas) AS promedio_venta,
                venta - (SELECT promedio_venta) AS `Diferencia_P.Venta` 
                FROM ventas v
                ) AS Ventas_Promedio
            WHERE `Diferencia_P.Venta` > 1;

        ```
            
        Otro Ejemplo:
        ```sql
            SELECT tb_A.nombre ,SUM(tb_A.pago) as "pago total", SUM(tb_A.saldo) as "saldo total"
            FROM (
                    SELECT v.id_venta,c.Nombre,v.Venta, SUM(p.pago) AS pago,
                    v.Venta - SUM(p.pago) AS saldo
                    FROM  pagos p
                    JOIN ventas v
                    USING (id_venta)
                    JOIN clientes c
                    USING (id_cliente)
                    GROUP BY v.id_venta, c.Nombre
                    HAVING saldo > 0
                    ORDER BY c.Nombre
                    ) AS tb_A
            GROUP BY tb_A.nombre
            
        ```
* **` AS `** : Se usa para cambiar el nombre a columnas o asignar un nombre a una nueva columna con una operación previamente hecha. Se puede asignar un nombre con espacios siempre y cuando este entre signos de admiración Ejm: *"Hola Mundo"*

    ```sql
        SELECT clave_producto, fecha, venta, venta * 1.16 as venta_iva

        SELECT clave_producto, fecha, venta, venta * 1.16 as "venta iva"
    
    ```
* **` WHERE `** : Se usa mayormente para filtrar las **columnas** según con los operadores lógicos que le indiquemos (<,>,<=,>=,!=,<>) <> = diferente de... El orden de comandos usados es ``SELECT,FROM,WHERE``.

    ```sql
        SELECT ID_local, clave_producto, venta
        from ventas
        WHERE ID_local < 2

    ```
    * Filtrando una agrupación por Fechas.

        ```sql
        
            SELECT c.Nombre, Fecha_venta,SUM(v.venta) as suma_venta
            FROM ventas v
            JOIN clientes c
            USING (ID_Cliente)
            WHERE Fecha_venta BETWEEN  "2017-01-01" AND "2017-12-31"
            GROUP BY ID_Cliente; 
            
        ```
    * También usamos `WHERE` para hacer Sub-Queries

        ```sql
            SELECT e.Nombre, e.Edad
            FROM empleados e
            WHERE Edad > (
                            SELECT AVG(Edad) AS Promedio_Edad
                            FROM empleados
                            );
        ```
    * Usando `WHERE` para búsqueda de texto:

        ```
            WHERE clave_producto NOT LIKE "%z" <!--Obia texto que termine en Z -->
            WHERE clave_producto LIKE "%z%" <!-- texto que contenga en Z en el centro ignorando su inicio y final-->

            WHERE clave_producto LIKE "10_" <!-- texto de 3 dígitos que empieze con 10 -->
        ```

* **`GROUP BY`** : Agrupa por el tipo previamente diseñado en una columna con su operación (SUM(), MAX(), MIN(), AVG(), COUNT()). Es recomendable agrupar por el nombre de una de las columnas que vamos a mostrar en `SELECT`
    ```sql
        SELECT ID_local, clave_producto, SUM(venta) AS venta_total
        FROM ventas
        WHERE clave_producto = "pzz"
        GROUP BY ID_local
        ORDER BY venta_total DESC

    ```
* **`HAVING`** : Se usa para seguir filtrando después del `WHERE`; también puede ir después del `GROUP BY`. Indicamos la columna a aplicar la condición de agrupación. Suele usarse para filtrar columnas que creamos en la visualización que llevan operaciones como sumar, las referenciamos con el nombre que le asignamos tras el `AS`.
    ```sql
        SELECT ID_local, clave_producto,SUM(venta) AS venta_total
        FROM ventas
        WHERE clave_producto = "pzz"
        GROUP BY ID_local, clave_producto
        HAVING venta_total > 1500
        ORDER BY venta_total DESC;

    ```
* **` AND OR NOT `** : Operadores. Es necesario después de poner el operador indicar el nombre de la columna de nuestra lógica.
  
    ```sql
        WHERE clave_producto = "pzz"  and ID_local = 2

        WHERE clave_producto = "pzz"  and ID_local = 2 or venta > 1000

        WHERE NOT clave_producto = "pzz"  and ID_local = 2

    ```
* **`IN`** : Este operador es usado indicar o devolver un conjunto de datos multiples (tablas, filas, datos,etc) en cambio el operador `=` solo regresa un valor. También simplifica el operador `OR` y no escribir el nombre de la columna y el dato que queremos igualar a traer. Se traduce como "Este en.." Este operador busca datos específicos o conjunto de ellos ("","") dentro de las columnas.

    ```sql
        WHERE clave_producto in ("pzz", "brr", "qsd" )

    ```
* **`BETWEEN`** : Este operador es usado para simplificar el operador `AND` e indicar valores entre un rango de valores a indicar.

    ```sql
        WHERE venta BETWEEN 1000 and 3000
    
    ```
* **`LIKE`** : Hace un match de búsqueda. Es normalmente usado para caracteres de texto, pero también funciona bien con caracteres numéricos. Este operador es usado para búsqueda de caracteres en las columnas. **` % `** indica "encuentra cualquier carácter antes de .." (si lo ponemos al final) o "después de.."(si lo ponemos en el inicio), **` _ `** indica encuentra un carácter según el numero de caracteres que querramos representándolo en numero de guiones bajos que indiquemos.

    ```sql
        WHERE clave_producto NOT LIKE "%z" <!--Obia texto que termine en Z -->
        WHERE clave_producto LIKE "%z%" <!-- texto que contenga en Z en el centro ignorando su inicio y final-->

        WHERE clave_producto LIKE "10_" <!-- texto de 3 dígitos que empieze con 10 -->

* **`REGEXP`** : Expresiones Regulares. Este operador es usado mayormente para texto. `^` Encontrar al inicio, `$` Encontrar al final. `|` Indica "o".

    ```sql
        SELECT * from datos.empleados
        WHERE Apellido REGEXP "^ez"*

        SELECT * from datos.empleados
        WHERE Apellido REGEXP "ez$"*

        SELECT * from datos.empleados
        WHERE Apellido REGEXP "ez|iz|za$"

    ```
* **`ORDER BY`** : Ordena datos de columnas (indicamos el nombre de la columna a ordenar) de forma ascendente por defecto, en este orden muestra los valores `null` primero. También las podemos ordenas con operaciones. `DESC` Descendente, `ASC` ascendente.

    ```sql
        ORDER BY nombre, apellido DESC

        ORDER BY Edad * 2 ASC

    ```
* **`NULL`** : Devolverá los valores nulos o excluirlos en nuestra búsqueda.
    ```sql
        WHERE Domicilio IS NULL

        WHERE Domicilio IS NOT NULL
    ```
* **`LIMIT`** : Devolverá los valores a partir de donde indiquemos (hasta donde limite). También podemos (seguido de una coma ",") pedir la cantidad de registros que queremos.
    ```sql
        SELECT * from datos.ventas
        LIMIT 5

        SELECT * from datos.ventas
        LIMIT 5,9

    ```
* **`UPDATE .. SET`** : Se suelen usar para actualizar datos o renombrar datos de una tabla.
En la condición `WHERE` podemos indicar la columna key con el nº de fila o cualquier otra columna (clase) como "Tipo_A" en donde modificaría muchas filas con valor Tipo A.<br><br>
>**UPDATE** (tabla)<br>
>**SET** columna_A = 7 , columna_B = "pin" *(ambos >valores a cambiar)*<br>
>**WHERE** columna_key = 5(nº de fila) *(donde coincida..)*;

```sql
    UPDATE ingredientes
    SET 
        precio_porcion = 7 , clave_ingrediente = "pin"
    WHERE ingredientes_id = 5;

```
    Para multiples filas con condicional dependiendo del tipo de otra columna:
```sql
    UPDATE archivo_venta
    SET venta = venta * 1.15  <!--Columna = Columna*1.15-->
    WHERE id_local IN (
                SELECT id_local
                FROM local
                WHERE letra_zona IN ("D","C")
                );
    -- Todos los datos de las columnas id_local (3,4) serán multiplicadas x 1.15 sus ventas
    
```
    Para Sub Correlaciones, el `WHERE` itera con cada una de las columnas con respecto a una columna_tipo: Venta mayor al promedio de cada "ID_Local" 
```sql
    SELECT *
    FROM ventas v
    WHERE v.venta > (
                SELECT  AVG(venta)
                FROM ventas
                WHERE ID_local = v.ID_local
                    );
    
```
* **`WITH ROLLUP`** : Añade un total de suma en la parte final inferior de la tabla de solo datos numéricos excluyendo los datos texto automáticamente. También puede agrupar entendiendo el tipo de total, para ello se indica 2 columnas condicionales en el `GROUP BY`. Debe ir al final de las columnas a agrupar de `GROUP BY`.
    ```sql
        SELECT ID_local, SUM(venta) AS venta_total
        FROM ventas
        GROUP BY id_local WITH ROLLUP;

    ```
    * Por tipo de total:

        ```sql
            SELECT ID_local, clave_producto,SUM(venta) AS venta_total
            FROM ventas
            GROUP BY id_local, clave_producto WITH ROLLUP;

        ```
* **`ALL`** : Indica tomar todos los valores ya sea de una columna. Se usa para itera sub queries cuando estas no son filtradas por un dato sino por una lista de valores.
    ```sql
        -- Este se comparará con todos los valores de local 2 teniendo al máximo valor de esa columna.
        SELECT *
        FROM ventas
        WHERE venta > ALL (
                        SELECT v.venta
                        FROM ventas v
                        WHERE v.ID_local = 2
                            ) 
                            
    ```
    * Iterar Lista arrojada por Sub Query

        ```sql
            SELECT * 
            FROM ventas v
            WHERE v.Venta > ALL (
                            SELECT Venta
                            FROM ventas
                            WHERE ID_producto = 2
                            )
                            
        ```
* **`ANY`** or **`SOME`** : Indica tomar Cualquier valor ya sea de una columna.
    ```sql
        -- Se comparará con todos los valores de local 2 mostrando todos los valores hasta el mínimo valor de esa columna.
        SELECT *
        FROM ventas
        WHERE venta > ANY (
                        SELECT v.venta
                        FROM ventas v
                        WHERE v.ID_local = 2
                            ) 
                            
    ```
* **`DISTINCT`** : Indica valores no repetitivos dentro de una columna (Valores Únicos).
    ```sql
        SELECT COUNT(DISTINCT clave_producto) AS claves FROM ventas;

    ```
* **`EXISTS`** : Indica si existe Cualquier valor de una columna. Se complementa también con `NOT` en caso de encontrar las no coincidencias. Para Usar `EXISTS` debe ir solo con el `WHERE` y en la SUB QUERY es necesario igualar para enlazar las columnas con los datos a comprobar.
    ```sql
        -- Empleado que si hicieron alguna venta.
        SELECT *
        FROM empleados e
        WHERE EXISTS (
                    SELECT v.venta_empleado 
                    FROM ventas v
                    WHERE v.venta_empleado = e.ID_empleado
                    );

    ```
* **`DELIMITER`** : Configura el símbolo con el que sql entenderá como fin de bloque de código. Puede ser **" ; "** (como esta por defecto) ó **" $$ "** para procedimientos `CREATE PROCEDURE`. Una vez cambiado es recomendable regresarlo como estaba por defecto **" ; "**. **Para VS Code no es necesario cambiar el `DELIMITER`**
    ```sql
      DELIMITER $$
      CREATE PROCEDURE sp_ventas_pizza ()
      BEGIN
          SELECT *
          FROM ventas v
          WHERE v.clave_producto = "pzz";
      END $$
      DELIMITER ;

      --Lo mismo pero en VSCODE
      CREATE PROCEDURE sp_ventas_pizza ()
      BEGIN
            SELECT *
            FROM ventas v
            WHERE v.clave_producto = "pzz";
      END;

    ```
* **`SET`** : Se usa para manipular las columnas y hacer operaciones con ellas.
    ```sql
        SET factor_mejora = (ventas_total/ventas_conteo) * 1.10;

    ```
* **`NEW.`** : Toma el ultimo valor ingresado en una tabla a la que indicaremos.
    ```sql
            UPDATE orden 
            --(columna de pago_orden)
            SET Balance = Balance + NEW.cantidad 
            --(New="Toma el ultimo registro que tiene la compu")
            WHERE orden = NEW.orden;
    ```


## 2.- *Trabajar con Multi Tablas:*

* **`JOIN ... ON`** : Une 2 tablas **Coincidiendo el valor de una Columna de una tabla, con el valor de la Columna de la otra tabla a unir**. Sin importar los nombres de las columnas los valores a coincidir deben ser iguales, dentro de una misma base de datos o diferentes. Se usa para jalar una columna con datos de otra tabla y añadirla a la consulta que estamos haciendo.<br><br> ``join`` (tabla a extraer) ``ON`` (tabla).(Columna) = (tabla).(Columna a mostrar).<br><br> 
``On`` Indica la primera tabla donde se le añadirá de lado la nueva tabla a hacer join.<br> *"**añadir** tabla_b **sobre** tabla_a **=** tabla.columna a mostrar"*
    ```sql
        select * from ventas v
        join local l on v.ID_local = l.ID_local

    ```
    * **Para diferentes bases de datos:** Indicamos con un " . " el origen de la base de datos con su tabla a usar aparte de la tabla de donde nos situamos inicialmente.
        ```sql
            use periodos;
            SELECT * FROM periodo1 p1
            JOIN datos.local dl
            ON p1.local = dl.Letra_zona
            
        ```
    * **Para multiples tablas dentro de una misma base de datos:** Se usará multiples `JOIN` para traer los datos de sus columnas independientemente de donde tengamos nuestro `FROM`, podremos hacer la conexión de tablas lejanas mediante tablas que nos lleven a ella aunque no las mostremos por `SELECT`:

        ```sql
            SELECT v.venta, c.nombre as cliente , z.Zona, p.producto
            FROM ventas v JOIN clientes c
            --ON v.ID_cliente = c.ID_cliente
            USING (ID_cliente)
            JOIN zona z
            --ON v.ID_zona = z.ID_zona
            USING (ID_zona)
            JOIN producto p
            --ON v.ID_Producto = p.ID_Producto
            USING (ID_Producto);

            -- Venta por cliente, Zona  y producto
            
        ```

* **`INNER JOIN`** : Es el ``JOIN`` por defecto. Esta union mostrara los datos de solo la intersección de Tabla A y B.
* **`LEFT JOIN`** : Esta union mostrara los datos de la tabla izquierda (Tabla A) con la intersección. La tabla A es la que indicamos en el `FROM` y la tabla B es la que va después del `LEFT JOIN`.
* **`RIGHT JOIN`** : Esta union mostrara los datos de la tabla derecha (Tabla B) con la intersección.
* **`FULL JOIN`** : Esta union mostrara todos los datos de las tablas A y B incluyendo la intersección.

* **`USING ()`** : Reemplaza el tener que hacer un `JOIN ON` indicando la misma columna.
    ```sql
        SELECT * FROM periodo1 e
        JOIN datos.empleados d 
        -- ON e.ID_Empleado = d.ID_Empleado (omite)
        USING (ID_Empleado)
        
    ```
* **`CROSS JOIN`** : Combina todos los registros de una tabla con todos los registros de otra. Si los tamaños de las filas de las tablas difieren estas se completaran repitiéndose.

* **`UNION`** : Concatena datos debajo de otros. Para ello se debe trabajar con la misma cantidad de columnas sino no se unirán, No es necesario que tengan el mismo nombre las columnas a adicionar.<br> El nombre de la nueva columna con los datos concatenados sera del primer `SELECT` por ello usamos `AS` para cambiarle el nombre.
    ```sql
        SELECT producto AS Items FROM productos
        UNION
        SELECT ingredientes FROM ingredientes
    ```
## 3.- *Trabajar con Datos:*

### Tipos de Datos:
Indicaremos el **DataType** de los datos que contendrá las columnas de la tabla. Es importante ajustar los datos de las columnas a los usos que ella misma tendrá para no estar acumulando datos innecesarios como espacios en blanco o "0". De esta forma ahorraremos en memoria.

  * **Numéricos:**
    * **`TINYINT`** : Almacena hasta 127 caracteres. (Edades,etc)
    * **`SMALLINT`** : Permite almacenar hasta 32k artículos en una BD.
    * **`MEDIUMINT`** : Permite almacenar 8 millones de usuarios (datos).   
    * **`INT`** : Es el mas usado, puede almacenar hasta 250 millones de usuarios. 
    * **`BIGINT`** : Puede almacenar 300 mil millones de usuarios en una BD.
    * **`FLOAT`** : Almacenar números decimales. 4b
    * **`DOUBLE`** : Almacenar números decimales. 8b
    * **`DECIMAL`** : Indica tipo Decimal. (nº de dígitos del numero, nº enteros no decimales)

  * **Texto o Alfanuméricos:**
    * **`CHAR`** : Almacenar hasta 255 caracteres.
    * **`VARCHAR`** : Variable Character. Permite almacenar hasta 65,535 caracteres .Es un tipo de dato **Texto**. Podemos indicar la cantidad de caracteres que tendrá los datos del VARCHAR con un paréntesis *VARCHAR(10)*
    * **`TEXT`** : Texto largo, a diferencia de `VARCHAR(n)` esta no se puede limitar la longitud máxima de una columna. Otra diferencia es que los campos ``VARCHAR`` pueden indexarse, los campos ``TEXT`` no pueden. Los campos de tipo ``VARCHAR`` se almacenan en línea mientras que ``TEXT`` se almacenan fuera de línea.
    * **`ENUM("VERDE","BLANCO","ROJO")`** : Crea una item con 3 tipos de el.
  
  * **Fecha y Hora:**
    * **`DATE`** : AA-MM-DD 
    * **`TIME`** : HH:MM:SS
    * **`DATATIME`** :  AAAA-MM-DD HH:MM:SS
    * **`TIMESTAMP`** :  AA-MM-DD HH:MM:SS
    * **`YEAR`** : AAAA ó AA

  * **blob:** Es un archivo, son usados para almacenar imágenes, videos, etc. No es recomendable almacenar archivos en "SQL" por tema de desempeño.
    * **`TINYBLOB`** : Almacena datos binarios hasta 255b en archivos.
    * **`BLOB`** : Almacena hasta 65kb.
    * **`MEDIUMBLOB`** : Almacena hasta 16MB.
    * **`LONGBLOB`** : Almacena hasta 4GB.


### Atributos: 

Indican el tipo de columna que tenemos con sus respectivos atributos.

  * **`PK`** : Primary Key, indica el identificador único para la tabla con la que dependen las demás columnas a rellenar.
    ```sql
        PRIMARY KEY (columna_A)
        
    ```
  * **`NN`** : Indica que en la columna no habrá valores nulos. Este suele ir junto con el ``PK`` para que el identificador único no tenga valores nulos.
    ```sql
        NOT NULL
        
    ```
  * **`UQ`** : Unique Index.
  * **`B`** : Valores binarios.
  * **`UN`** : unsigned data type.
  * **`ZF`** : Encaso de ser una columna numérica activando el `ZF` rellenará los valores con un"0"
  * **`AI`** : Auto Incremental. Incrementará en valores de 1 para columnas numéricas. Indicaremos a partir de que numero empezará a contar de uno en uno.
    ```sql
        CREATE TABLE Tabla_B(
            COD_PRODUCTO INT(15) PRIMARY KEY AUTO_INCREMENT,
            NOMBRE VARCHAR(20),

        )AUTO_INCREMENT = 100;
        
    ```

  * **`G`** : Generated column.
  * **`Default/Expression`** : Indicamos un valor den default.
<br><br>

### Comandos:

* **`INSERT INTO  .. VALUES`** : Inserta un valores dentro de un tabla según el orden de columnas que tenga la tabla, en ese orden se insertaran los datos teniendo en cuenta el tipo de columnas que son.<br> También puede insertar un valor especifico dentro de una columna de la tabla, cada dato insertado dentro de la columna indicada se asignara en una fila diferente.<br>
Para las columnas con `auto_increment` podemos ponerles `null` para no afectarlas o simplemente ignorarlas y añadir los datos sobre las columnas deseadas.<br><br>
``INSERT INTO`` Tabla (Columna) ``VALUES`` ("Dato1"),("Dato2")

    ```sql
        INSERT INTO ingredientes (Ingredientes)
        VALUES ("salchicha"), ("jamon"), ("salami")   
    ```
  * Para Insertar datos en cada columna indicamos las columnas a rellenar seguido rellenamos dentro del paréntesis con "," para ir columna por columna. Cada paréntesis indica una fila nueva.

    ```sql
        INSERT INTO datos.ingredientes (Ingredientes, clave_ingrediente)
        VALUES ("salchicha", "slc"), ("jamon","jm"), ("salami","slm")  
    ```
    * Insertar valores para cada columna dentro de una Tabla:

        ```sql
            INSERT INTO pago_orden
            VALUES(default,CURDATE(),499,9999,100);
            --(se llena conforme al orden de columnas que tocan en la tabla "pago_orden")
        ```
* **`LAST_INSERT_ID()`** : Indica la ultima fila de la columna con la "KEY".<br><br>
    ```sql
        INSERT INTO venta_detalle
        VALUES (LAST_INSERT_ID(),"llevar")
    ```

## 3.- *Resumir Datos:*

### Funciones de Agregación:

Estas funciones van justo después del `SELECT`, son operaciones que se les hace a las consultas. Tiene el siguiente formato.<br><br>

> **SELECT** MAX(Columna) **FROM** Tabla

> **SELECT** MAX(Columna) AS MÁXIMO **FROM** Tabla

* **`MIN()`** : Arroja el valor mínimo de la columna indicada.
* **`MAX()`** : Arroja el valor máximo de la columna indicada. 
* **`AVG()`** : Arroja el valor promedio de la columna indicada.
* **`SUM()`** : Arroja la suma de la columna indicada.
* **`COUNT()`** : Contara todos los datos de la columna indicada, excepto los tipo `NULL` para ellos es necesario indicar `(*)` para que los incluya en la cuenta. 

## 4.- *Funciones SQL:*

### Funciones Numéricos:

* **`ROUND()`** : Redondea un numero decimal a un entero dependiendo si es mayor o no a 0.5 para el redondeo superior o inferior del entero a arrojar. También podemos usar `ROUND` para mostrar la cantidad de decimales que queremos del numero decimal.<br>
**SELECT** ROUND(Valor, nºdecimales a mostrar);
    ```sql
        SELECT ROUND(2.343, 2);

    ```
* **`TRUNCATE()`** : Elimina Decimales que no conservemos (el resto).<br>
**SELECT** TRUNCATE(Valor, nºdecimales a Conservar);
    ```sql
        SELECT TRUNCATE(2.343, 2);

    ```
* **`CEILING()`** : Redondea al **entero** **superior** del numero decimal.<br>
**SELECT** CEILING(Valor);
    ```sql
        SELECT CEILING(2.343);
        
    ```
* **`FLOOR()`** : Redondea al **entero** **inferior** del numero decimal.<br>

    ```sql
        SELECT FLOOR(2.343);

    ```
* **`ABS()`** : Indica el valor absoluto del número que indiquemos.<br>

    ```sql
        SELECT ABS(-2.343);

    ```
* **`RAND()`** : Arroja una serie de números aleatorios decimales que están dentro de los valores enteros 0 y 1. Arroja un 0 con 16 decimales random.<br>

    ```sql
        SELECT RAND();

    ```
### Funciones para Textos:

* **`LENGTH()`** : Arroja el numero de caracteres de un texto o palabra(el espacio lo cuenta como un caracter).<br>

    ```sql
        SELECT LENGTH("ejemplo 200")

    ```
* **`UPPER()`** : Convierte el texto en todo mayúscula (Ignora los números).<br>

    ```sql
        SELECT UPPER("ejemplo 200")

    ```
* **`LOWER()`** : Convierte el texto en todo minúscula (Ignora los números).<br>

    ```sql
        SELECT LOWER("EJEMPLO 200")

    ```
* **`TRIM()`** : Elimina todos los espacios del texto dejando unicamente un espacio en la separación de palabras.<br>
También podemos ser específicos si queremos usar `LTRIM` o `RTIM` eligiendo el lado que queremos que elimine los caracteres vacíos.<br>

    ```sql
        SELECT TRIM("   EJEMPLO 200   600  ");
        SELECT LTRIM("     EJEMPLO 200");
        SELECT RTRIM("EJEMPLO 200     ");

    ```
* **`LEFT()` y `RIGHT`** : Coje los caracteres de la izquierda o derecha según el que usemos, indicándole cuando caracteres queremos que coja.<br>

    ```sql
        SELECT LEFT ("ejemplo 200",3);
        SELECT RIGHT ("ejemplo 200",3);

    ```
* **`SUBSTRING()`** : Coje caracteres de un texto delimitando a partir de que caracter cojer hasta que caracter final a tomar.<br>

    ```sql
        SELECT SUBSTRING ("ejemplo 200",2,4);

    ```
* **`LOCATE()`** : Busca un caracter indicado, retornando el numero de la posición donde encuentra el primer caracter de coincidencia con el que le indicamos a buscar en el texto.<br>

    ```sql
        SELECT LOCATE("ejmp","ejemplo 200",2,4);

    ```
* **`REPLACE()`** : Reemplaza un caracter a indicar de un texto por uno que le indiquemos a reemplazar. Requiere 3 argumentos<br><br>

("TEXTO ORIGINAL","PALABRA A COJER","PALABRA A REEMPLAZAR")

    ```sql
        SELECT REPLACE("ejemplo 200","200","400");

    ```
* **`CONACT()`** : Concatena los caracteres, uno a lado del otro. Podemos concatenar los caracteres o palabras que queramos sin limite.<br>

    ```sql
        SELECT CONCAT("ejemplo"," " ,"200");

    ```

### Funciones para Fechas:

* **`NOW()`** : Muestra la Fecha de hoy (Actual).<br>

    ```sql
        SELECT NOW();
        --'2022-02-15 20:39:33'

    ```
* **`CURDATE()`** : Muestra la Fecha de hoy (Actual) en formato Año-Mes-Dia.<br>

    ```sql
        SELECT CURDATE();
        --'2022-02-15'

    ```
* **`CURTIME()`** : Muestra la Hora de hoy (Actual) en formato Año-Mes-Dia.<br>

    ```sql
        SELECT CURTIME();
        --'2022-02-15'

    ```
* **`DAYNAME(); MONTHNAME()`** : Arroja el nombre del día o mes.<br>

    ```sql
        SELECT DAYNAME('2003-12-31 01:02:03');
        SELECT MONTHNAME('2003-12-31 01:02:03');

    ```
* **`EXTRACT()`** : Arroja el día o mes o año que le indiquemos en formato numérico.<br>

    ```sql
        SELECT EXTRACT(MONTH FROM NOW());
        SELECT EXTRACT(MONTH FROM '2003-12-31 01:02:03');

    ```
* **`DATE()`** : Extrae el años mes y dia de una fecha.<br>

    ```sql
        SELECT DATE('2003-12-31 01:02:03');
        --'2003-12-31'

    ```
* **`YEAR()`** : Extrae solo el año de una fecha.<br>

    ```sql
        SELECT YEAR("2003-12-31 01:02:03");
        --'2003'

    ```
* **`ADDDATE()`** : Suma mediante **días** a la fecha actual arrojando la fecha sumada de la operación.<br>

    ```sql
        SELECT ADDDATE ('2008-01-02');
        --'2008-02-02'

    ```
### Crear Funciones:
Para la Creación de funciones es necesario  indicar los atributos almenos uno sino no se creara la función.

#### Atributos para Funciones:
 * `DETERMINISTIC` : SIempre retornara los mismos resultados para los mismos parámetro usados. Si indicamos en nº de un empleado debe regresar el mismo valor.
 * `MODIFIES SQL DATA` : Esta función va a tener lineas SQL como `INSERT`, `UPDATE`, `DELETE` para modificar información.
 * `READS SQL DATA` : No modifica nada solo la lee. Modo Read
 * `NO SQL` : Para cuando no tenemos ninguna instrucción de SQL.


## 5.- *Condicionales SQL:*

* **`IFNULL()`** : Indica si algún valor es nulo.<br>
```sql
    SELECT nombre, IFNULL(ID_gerente, "Gerente") AS Nivel_Gerencial
    FROM empleados
    
```
* **`COALESCE()`** : Indica que si todas las columnas tiene un valor es nulo dentro de las columnas que hemos indicado a buscar, arrojara el valor que hemos escrito.<br> En caso de que sola una columna tenga un valor nulo y la siguiente no, traerá el valor de la segunda columna.<br>
```sql
    SELECT nombre, COALESCE(ID_gerente, Domicilio, "Gerente") AS Nivel_Gerencial
    FROM empleados;

```
* **`IF()`** : Condicional. Requiere de 3 argumentos.<br><br>

(Expresión, Primera opción si se cumple, Segunda opción en caso no se cumpla)

```sql
    SELECT v.venta_empleado, v.venta,
    IF(v.venta>1300,"Bono","-") AS Bono
    FROM ventas v;

```
* **`CASE()`** : Condicional. Se usa para tener multiples casos condicionales (segmentar) de una manera practica. Requiere un `END` al final para cerrar el `CASE`, también es necesario ordenar las condicionales de manera Descendente (de mayor a menor) para que pueda iterar de manera correcta.<br>

```sql
SELECT v.venta_empleado, v.venta,
CASE
    WHEN v.venta>1300 THEN "Bono Max"
    WHEN v.venta>1000 THEN "Bono Normal"
    WHEN v.venta>500 THEN "Bono Min"
    ELSE "-"

END AS Bono
FROM ventas v;

```

## 6.- *VARIABLES:*

Hay 3 tipos de variables:
 * **Definidas por el Usuario:** Estas se definen con un `SET` y un **" @ "**. Su Alcancé es toda la sesión con la que estamos trabajando.
    ```sql
        SET p_local_id = 1;
    ```

 * **Local:**  Estas se definen con un `DECLARE` seguido del nombre de la variable que asignaremos y su tipo de dato. Su Alcancé esta entre el `BEGIN` y el `END`.
    ```sql
        DECLARE variable_1 INT DEFAULT 0;
    ```
 * **SERVER SYSTEM:**  Estas son para la configuración de sql, se definen con 2 arrobas **" @@ "**

## 7.- *Transacciones:*

Son actualizaciones de datos a las tablas. Si 2 transacciones se añaden a la misma tabla habrá un tiempo de espera hasta que una de las 2 se complete podrá entrar la siguiente transacción. En caso bote error por **Lost Connection** podríamos usar el `ROLLBACK` para cancelar nuestra transacción dejando libre la confección en caso demore mucho en subirse.

ACID Properties

* Atomicity: No se pueden romper, trabajan como una unidad de trabajo (no importa si tienes 10 o mas instrucciones), se ejecutan todas o ninguna. Como por ejemplo no se puede retirar sin que genere otro efecto, o funciona toda la operación (bloque de código) o no funciona nada.

* Consistency: La consistencia en las transacciones nos asegura que nuestros datos van a ser consistentes.

* Isolation: (Aislamiento) Los datos se van a proteger y no se va a poder modificar la misma información o bloque de código cuando otra transacción intente modificarla. Permitiendo que solo una operación pueda afectar los datos hasta que termine una transacción o instrucción. Quiere decir de uno en uno.

* Durability: Los cambios serán permanentes una vez ejecutada la transacción.

## 8.- *JSON:*

```sql
    ALTER Table `datos`.`productos`
    ADD COLUMN `Caracteristicas` JSON NULL AFTER `clave_producto`;
```
Funciones JSON:
    
 * **`JSON_OBJECT`** : Crea información JSON.
 
    ```sql
        UPDATE productos
        SET Caracteristicas = JSON_OBJECT("dimension",JSON_ARRAY(5,10,20),
                              "productos_mix",JSON_ARRAY("pizza","burrito"),
                              "cantidad",2
                              )
        WHERE productos_id = 5;
    ```
 * **`JSON_EXTRACT`** : Extraer información de las llaves JSON.

    ```sql
        select productos_id, json_extract(Caracteristicas, '$.dimension') AS Caracteristicas
        from datos.productos
        where productos_id = 5;
    ```
 * **`JSON_SET`** : Actualizar un dato del JSON.

    ```sql
        UPDATE productos
        SET Caracteristicas = JSON_SET(Caracteristicas, '$.dimension',5)
        WHERE productos_id = 5;
    ```
 * **`JSON_REMOVE`** : Borra un dato del JSON.

      ```sql
          UPDATE productos
          SET Caracteristicas = JSON_REMOVE(Caracteristicas, '$.dimension',5)
          WHERE productos_id = 5;
      ```
## 9.- *Modelado de Datos:*
Se refiere al diseño de nuestros cuadros y la relaciones que vamos a realizar para nuestras tablas.

### Tipos de tablas.
En el diseño de tablas es necesario definir en que tablas almacenamos nuestros datos, y otro para registro de hechos.

  * **Tabla de Dimensiones** : Es una tabla con el fin de guardar datos como por ejemplo el listado de nuestros items con sus características que las describen: Precio, Color, Peso, Categoria, etc. (suele tener una relación de 1 a 1 con otras tablas de dimensiones dado que el item o código aparece una sola vez)
   
  * **Tabla de Hechos** (Fact Table) : Aquí se registra hechos numéricos o transacciones que hacen uso de los items almacenados en la Tabla de Dimensiones. Esta tabla se usa para hacer reportes como ventas, compras, etc. (suele tener una relación de 1 a muchos con otras tablas, incluyendo la de dimensiones, dado que el item se puede repetir muchas veces)

### Tipos de identificadores para las tablas.

  * **Primary Key (PK)** : Se hace uso para tener un identificador único en una tabla.
  * **Foreign Key (PK)** : Se refiere a un identificador que viene de otra tabla. Ejm: ID_Venta con ID_Producto
  * **Composite Primary Key (CPK)** : Identificador compuesto. Es la union de 2 PK para crear un único identificador. Es usado para cuando queramos identificarlos y no tengamos como.

## 10.- Diseño de Base de Datos

Una vez tenida toda la información del negocio ejecutamos 3 pasos:

  * **Modelo Conceptual** : se refiere a la creación de nuestras tablas y relaciones. Para ello usaremos una pagina [LucidChart](https://lucid.app/lucidchart/471ac762-dde1-410e-addd-0adbc449927f/edit?beaconFlowId=DC91A2DE5D504041&page=0_0&invitationId=inv_6d011e43-14cf-47f5-b554-7d1ee83526ff#) como plataforma para diseñar base de datos.

  * **Modelo Lógico** : Es el paso previo a implementarlo a nuestro gestor, especificando el tipo de datos que vamos a usar, tipo de relaciones (1 a 1 ó 1 a muchos), y Tipo de tablas (dimensiones y hechos).

Es importante hacer otro cuadro para las columnas que tengas muchas letras o muchos tipos como "Color", "Nombre_cliente"; y reemplazarlos por tipos de datos "int" con el fin de agilizar la base de datos y pese menos. A esta práctica se le llama **Normalización**. También se suele no poner columnas con campos calculables como "Total", "Nombre_Completo"; o cualquier otro campo que se pueda calcular con una consulta para ahorrar espacio y evitar errores.

Una vez terminado el modelo clickeamos en la pestaña **DataBase** **>** **Forward Engineer** del workbench para crear la base de datos del modelo propuesto. 
Para modificar nuestro modelo sea ya añadiendo un campo a una tabla para que corra es necesario usar **DataBase** **>** **Synchronize Model** para sincronizarlo con nuestro ultimo cambio. 
En caso quiera hacer ingeniería inversa de una base de datos ya hecha y desee abrir su modelo para ver las relaciones de sus tablas, para ello seleccionaremos la base de datos y clickearemos en **DataBase** **>** **Reverse Engineer**.

### Crear Modificar y Relacionar

Ejecutaremos lo mismo que lo anterior pero ya no en el Workbench sino ahora lo ejecutaremos con código. Ir al ejercicio [12)Crear, Modificar y Relacionar DB.sql](\\12\)Crear,%20Modificar%20y%20Relacionar%20DB.sql)

 * **Crear Base de Datos**
  ```sql
    create database if not exists ejemplo_datos;
    
  ```
 * **Crear tabla y relaciones**
   * **``FOREIGN KEY``** : Referencia como input una columna de una tabla ajena.

    > FOREIGN KEY fk_Nuevo_nombre (Columna a Referenciar y reemplaza)
    > REFERENCES Tabla_Ajena(Columna)
    ```sql
    create table if not exists compras (
    Compra_ID INT PRIMARY KEY AUTO_INCREMENT,
    cliente_ID INT NOT NULL,
    Total INT(30) not null,
    -- Relaciones.
    FOREIGN KEY fk_clientes_compras (Cliente_ID)
    REFERENCES clientes(cliente_ID)
      on update cascade
      on delete RESTRICT
    );
    
    ```
   * **``SHOW CREATE TABLE``** : Muestra las llaves foráneas.<br><br>
  
    ```sql
      SHOW CREATE TABLE Nombre; 
    ```

### Indexados

El fin de indexar campos es para agilizar el motor de búsqueda a la hora de hacer nuestras consultas como normalmente las ejecutamos. Es una forma en la que etiqueta datos que le indiquemos (Los mas concurrentes) para ahorrar en rendimiento cuando hagamos las consultas.

 * **EXPLAIN** : Nos arrojara el detalle de como busca datos dentro de nuestras consultas. Usamos el comando ``EXPLAIN``

  ```sql
    EXPLAIN SELECT venta_empleado FROM ventas_idx
    WHERE clave_producto = "pzz";
    
  ```
 * **Crear un Indexado** : Creamos un index (indicando su nombre al index) para agilizar nuestra consulta 

    > CREATE (index_nombre) ON (DB.Tabla)(Columna);

  ```sql
    CREATE index idx_producto ON db_index.ventas_idx (clave_producto);
    
  ```
    * **Index compuesto** : Cuando en nuestra consulta usamos mas de una columna para filtrar la información. Por ello ordenamos nuestro indice según las columnas que nos filtren la información de manera mas eficiente.
    ```sql
      create index idx_clavepro_venta on ventas_idx(clave_producto, venta);
      -- Consulta a mejorar el rendimiento
      EXPLAIN SELECT venta_empleado
      FROM ventas_idx
      WHERE clave_producto = 'pzz' AND venta > 200;
    ```
 * **SHOW INDEX IN or FROM** : Mostrara los diferentes indices de una tabla a indicar.

  > SHOW INDEX IN Tabla;

  ```sql
    SHOW INDEX IN ventas_idx;
    
  ```
 * **USE INDEX** : Indicamos de la lista de indices que tenemos cual queremos usar convenientemente para la consulta que planeamos hacer.

  ```sql
    USE INDEX (idx_producto);
    
  ```
 * **DROP INDEX IN or FROM** : Barrará los indices de una tabla a indicar.

  ```sql
    DROP INDEX idx_producto ON ventas_idx;     
  ```

## 11.- Asegurar Base de Datos

Al trabajar en equipo es necesario configurar los permisos para compartir información o DB con otros colaboradores. Cabe resaltar que no es necesario que otros colaboradores usen **MySql Workbench** dado que ellos pueden importar las bases de datos en **excel** *(Data > GetData > From DataBase > From MySql DataBase)*.
Debido a que el usuario que se va a conectar a nuestra DB no esta en nuestro local host le pasamos el puerto de conexión. *127.0.0.1:3306* junto con el nombre de la base de Datos ejm: *datos*

 * **CREATE USER** : Al momento de crear usuarios debemos indicar de que manera el usuario va a conectarse con nuestra base de datos. Ya sea por **@localhost**, IP **@127.0.0.1**, dominio o correo **@a2capacitaciones.com**, Sub Dominios **@"%.a2capacitaciones.com"**.
`IDENTIFIED BY` usamos para asignarle una contraseña.

  ```sql
    CREATE USER rodrigo IDENTIFIED BY "123456"
  ```
 * **mysql.user** : Este comando muestra todos los usuarios guardados con su detalle. El símbolo **%** indica que se puede conectar desde cualquier lugar.

  ```sql
    SELECT * FROM mysql.user

  ```
  * **SET PASSWORD FOR** : Cambia la contraseña

  ```sql
    SET PASSWORD FOR rodrigo = "123123";

  ```
  * **DROP USER** : Eliminar un usuario.

  ```sql
    DROP USER rodrigo;

  ```
  * **GRANT** : Otorga permisos o privilegios al los usuarios

  ```sql
    GRANT SELECT, INSERT, UPDATE
    ON datos.ventas TO rodrigo;

  ```
  * **REVOKE** : Elimina permisos o privilegios al los usuarios

  ```sql
    REVOKE SELECT, INSERT, UPDATE
    ON datos.ventas FROM rodrigo;

  ```

